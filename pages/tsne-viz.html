---
layout: default
title: Visualization of Publications on Large Language Models
description: An interactive t-SNE map of LLM papers with global search, a cluster legend, and optional node sizing by citations.
---

<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
/* ====== Simple, safe container (no sidebar subtraction) ====== */
:root{
  --page-gutter: clamp(12px, 2vw, 24px);

  /* match publications page look & feel */
  --bg:#ffffff;
  --card:#fff;
  --muted:#6b7280;
  --line:#e5e7eb;
  --shadow:0 1px 2px rgba(0,0,0,.06), 0 8px 24px rgba(0,0,0,.04);
  --brand:#1a73e8;
}

/* Centered wrapper with comfy gutters */
.full-bleed-right{
  box-sizing:border-box;
  width:100%;
  max-width:1200px;
  margin-left:auto;
  margin-right:auto;
  padding-left:var(--page-gutter);
  padding-right:var(--page-gutter);
}

/* Children can be full width inside this container */
.full-bleed-right > * { max-width: 100% !important; }

/* ===== Slim, sticky toolbars (same style language) ===== */
.toolbar{
  position:sticky; top:0; z-index:20;
  background: linear-gradient(#fff, rgba(255,255,255,.92));
  backdrop-filter: blur(4px);
  border:1px solid var(--line);
  border-radius:12px; padding:10px 12px; margin:8px 0 12px;
  display:flex; align-items:center; justify-content:space-between; gap:12px;
  box-shadow: var(--shadow);
}

.search{ display:flex; align-items:center; gap:.6rem; flex-wrap:wrap; }
.search label{ font-weight:700; font-size:.85rem; }
.search input[type="search"], .search input[type="text"]{
  width:clamp(220px, 32vw, 560px);
  padding:.45rem .6rem;
  border:1px solid #cbd5e1; border-radius:8px;
  font-size:.95rem; background-color:#f8fafc;
}
.search input:focus{
  outline:none; border-color:var(--brand);
  box-shadow:0 0 0 2px rgba(26,115,232,.18);
}
.search button{
  padding:.45rem .6rem; font-size:.85rem; border:1px solid #cbd5e1;
  border-radius:8px; background:#f8fafc; cursor:pointer;
}
.search button:hover{ background:#eef2f7; }
.small{ color:var(--muted); font-size:.9em; }

/* ===== New: size-by checkbox group ===== */
.sizeby-wrap{
  display:flex; align-items:center; gap:.55rem; flex-wrap:wrap;
}
.sizeby-label{
  font-weight:650;
  color:var(--muted);
  font-size:.9em;
}
.sizeby-group{
  display:flex; align-items:center; gap:.55rem; flex-wrap:wrap;
  padding:.25rem .35rem;
  border:1px solid #e5e7eb;
  border-radius:10px;
  background:#f8fafc;
}
.sizeby-item{
  display:flex; align-items:center; gap:.35rem;
  padding:.15rem .35rem;
  border-radius:999px;
  user-select:none;
}
.sizeby-item input{
  transform: translateY(0.5px);
}
.sizeby-item span{
  font-size:.88rem;
  color:#374151;
}
.sizeby-actions{
  display:flex; align-items:center; gap:.45rem; flex-wrap:wrap;
}
.sizeby-actions button{
  padding:.38rem .55rem;
  font-size:.82rem;
}

/* Map container */
#paperviz {
  width:100%;
  position:relative;
  min-height: 50vh;
  background:#fff;
  border:1px solid #eee; border-radius:8px;
  box-shadow: 0 1px 2px rgba(0,0,0,.035);
  overflow: hidden;
}

/* Canvas should fill the map */
#paperviz canvas{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  display:block;
}

/* Floating map UI (inside the map) */
#paperviz .map-ui{
  position:absolute;
  right:10px; top:12px;
  display:flex; flex-direction:column; gap:12px; z-index: 5;
}
.fab{
  width:36px; height:36px;
  border-radius:10px; border:1px solid #d1d5db; background:#ffffff;
  box-shadow: 0 2px 6px rgba(0,0,0,.08);
  font:600 18px/36px system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  text-align:center; cursor:pointer;
  transition: transform .08s ease, background-color .15s ease, box-shadow .15s ease;
}
.fab:hover{ background:#f5f7fb; transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,.10); }
.fab:active{ transform: translateY(0); }

/* Gesture hint (auto-fades) */
#paperviz .gesture-hint{
  position:absolute; right:56px; top:16px;
  background: rgba(34,34,34,.85); color:#fff;
  padding:6px 10px; border-radius:8px; font-size:.78rem;
  box-shadow: 0 2px 6px rgba(0,0,0,.15);
  opacity:0; pointer-events:none; transition: opacity .25s ease; z-index:5;
}
#paperviz .gesture-hint.show{ opacity:1; }

/* ---------- Sleeker cluster / year legend ---------- */
#cluster-legend-wrapper{
  margin-top:16px; padding:12px;
  border:1px solid #eee; border-radius:12px; background:#fff;
  box-shadow: 0 1px 2px rgba(0,0,0,.03);
  font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
}
#cluster-legend { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:10px; }
.legend-item {
  display:flex; align-items:center; gap:10px; padding:10px 12px;
  border:1px solid #e6e6e6; border-radius:999px; background:#fafafa; cursor:pointer;
  transition: transform .12s ease, background-color .2s, border-color .2s, box-shadow .2s, opacity .2s;
  user-select:none;
}
.legend-item:hover { background:#f5f7fb; transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,.06); }
.legend-item[aria-pressed="true"]{ background:#f0f6ff; border-color:#b8d3ff; box-shadow: 0 0 0 3px rgba(26,115,232,.12) inset; }
.legend-dot{ width:14px; height:14px; border-radius:50%; box-shadow: 0 0 0 2px #fff inset, 0 0 0 1px rgba(0,0,0,.06); flex:0 0 14px; }
.legend-text{ display:flex; flex-direction:column; gap:4px; min-width:0; }
.legend-row{ display:flex; align-items:center; gap:8px; min-width:0; }
.legend-title{ font-weight:650; font-size:.9rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.legend-count{ font-size:.75rem; padding:2px 8px; border-radius:999px; background:#fff; border:1px solid #e1e1e1; color:#555; }
.legend-tags{ display:flex; flex-wrap:wrap; gap:6px; max-width:100%; }
.legend-tag{ font-size:.75rem; line-height:1; padding:4px 8px; border-radius:999px; background:#fff; border:1px solid #eee; color:#444; white-space:nowrap; max-width:160px; overflow:hidden; text-overflow:ellipsis; }
.legend-item:focus-visible{ outline:none; box-shadow: 0 0 0 3px rgba(26,115,232,.25); }

/* Tooltip */
.tooltip { pointer-events:none; }

/* Year slider tweaks */
.range-wrap{ display:flex; align-items:center; gap:.6rem; flex-wrap:wrap; }
input[type="range"]{ accent-color:#1a73e8; }

/* Narrow screens */
@media (max-width: 680px){
  #paperviz { min-height: 360px; }
  .toolbar{ border-radius:10px; }
}
</style>

<h2 style="font-size: 1.8em; margin-bottom: 10px;">üó∫Ô∏è 2D Map of Papers</h2>
<p style="font-size: 1.05em;">
  Each dot represents a <strong>paper</strong> in this collection, positioned using
  <strong>t-SNE</strong> based on its content similarity. Use the search bar to
  filter by <strong>title</strong>, <strong>authors</strong>,
  <strong>abstract</strong>, or <strong>tags</strong> to explore related works
  interactively.
</p>

<div class="full-bleed-right">
  <!-- Search toolbar -->
  <div class="toolbar" role="search" id="searchToolbar">
    <div class="search">
      <label for="filtermap"><strong>Search</strong></label>
      <input type="search" inputmode="search" spellcheck="false" id="filtermap"
             placeholder="üîç Search papers‚Ä¶" aria-label="Search papers" />
      <button id="clearSearch" type="button" aria-label="Clear search">Clear</button>
      <span id="matchCount" class="small" aria-live="polite"></span>
    </div>
  </div>

  <!-- View toolbar (size by metrics (multi) + colour by year) -->
  <div class="toolbar" style="margin-top:-.4rem;" id="viewToolbar">
    <div class="search">
      <strong style="font-size:.85rem;">View</strong>

      <div class="sizeby-wrap" aria-label="Size dots by metrics">
        <span class="sizeby-label">Size by</span>

        <div class="sizeby-group" role="group" aria-label="Size by metrics (select multiple)">
          <label class="sizeby-item" title="Add size contribution based on citations">
            <input type="checkbox" class="sizeByMetric" id="size_citations" value="citations" />
            <span>Citations</span>
          </label>

          <label class="sizeby-item" title="Add size contribution based on Hugging Face likes">
            <input type="checkbox" class="sizeByMetric" id="size_hf" value="huggingface_likes" />
            <span>HF likes</span>
          </label>

          <label class="sizeby-item" title="Add size contribution based on GitHub stars">
            <input type="checkbox" class="sizeByMetric" id="size_gh" value="github_stars" />
            <span>GitHub stars</span>
          </label>
        </div>

        <div class="sizeby-actions">
          <button id="clearSize" type="button" aria-label="Disable all size metrics">No size</button>
        </div>
      </div>

      <div>
        <input type="checkbox" id="colorByYear" /> <span class="small">Colour by year</span>
      </div>
    </div>
  </div>

  <!-- Year toolbar (dual range) -->
  <div class="toolbar" id="yearControls" style="margin-top:-.6rem; display:none;">
    <div class="search">
      <label for="yearMin"><strong>Year</strong></label>
      <div class="range-wrap">
        <input type="range" id="yearMin" min="2000" max="2025" step="1" value="2000" aria-label="Minimum year">
        <input type="range" id="yearMax" min="2000" max="2025" step="1" value="2025" aria-label="Maximum year">
        <div class="small">
          <span id="yearMinVal">2000</span>‚Äì<span id="yearMaxVal">2025</span>
        </div>
        <button id="clearYear" type="button" aria-label="Reset year filter">All years</button>
      </div>
    </div>
  </div>

  <!-- Map -->
  <div id="paperviz">
    <div id="loadingViz" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center;">
      Loading visualization...
    </div>

    <!-- Canvas layer (replaces SVG dots) -->
    <canvas id="vizCanvas" aria-label="Paper map"></canvas>

    <!-- Floating map UI -->
    <div class="map-ui" aria-label="Map controls">
      <button class="fab" id="zoom_in"  aria-label="Zoom in"  title="Zoom in (+)">+</button>
      <button class="fab" id="zoom_out" aria-label="Zoom out" title="Zoom out (‚àí)">‚àí</button>
      <button class="fab" id="reset_view" aria-label="Reset view" title="Reset view (R)">‚åÇ</button>
    </div>

    <!-- One-time gesture hint -->
    <div class="gesture-hint" id="gestureHint">
      Drag to pan ¬∑ Scroll/Pinch to zoom
    </div>
  </div>

  <!-- Legend UNDER the map (cluster OR year depending on mode) -->
  <section id="cluster-legend-wrapper" aria-label="Cluster Legend">
    <h3 style="margin: 0 0 8px;">üß≠ Cluster Legend</h3>
    <button id="resetClusters" style="margin-bottom:10px;">Show All Clusters</button>
    <div id="cluster-legend"></div>
  </section>
</div>

<p>
  Please consider <a href="/contributing.html">contributing</a> by updating the information of existing papers or adding new work.
</p>

<script src="https://d3js.org/d3.v6.js"></script>

<script>
/* ----------------- Tap-to-toggle for tooltip (mobile) ----------------- */
document.addEventListener('click', function(e){
  const isInfo = e.target.closest('.info[data-tooltip]');
  document.querySelectorAll('.info[data-show]').forEach(el => { if (el !== isInfo) el.removeAttribute('data-show'); });
  if (isInfo) { e.preventDefault(); isInfo.toggleAttribute('data-show'); }
}, { passive: false });

/* ----------------- State ----------------- */
var allData = [];
var filteredData = [];
var selectedCluster = null;          // cluster id or null
var updateVisualization = () => {};
var currentTransform = d3.zoomIdentity;

/* Year slider state */
var yearMinBound = null;
var yearMaxBound = null;
var selectedYearMin = null;
var selectedYearMax = null;

/* Canvas + hit-testing */
var canvas = document.getElementById("vizCanvas");
var ctx = canvas.getContext("2d");
var dpr = window.devicePixelRatio || 1;
var quadtree = null;

/* Hover state (tooltip throttling + update only on change) */
var hovered = null;         // current hovered datum or null
var hoverRAF = 0;
var lastMouse = null;

/* ----------------- Search helper ----------------- */
var isMatch = function(d, searchTerm) {
  return searchTerm.length >= 3 && d._searchText.includes(searchTerm);
};

/* ----------------- Layout / scales ----------------- */
var margin = {top: 10, right: 24, bottom: 30, left: 40};
var width = 320 - margin.left - margin.right;   // initial; ResizeObserver fixes immediately
var height = 260 - margin.top - margin.bottom;

var color = d3.scaleOrdinal(d3.schemeCategory10);
var colorYear = d3.scaleSequential(d3.interpolateTurbo);

/* Keep domains generous; TSNE coordinates should fit here */
var x = d3.scaleLinear().domain([-25, 25]).range([0, width]);
var y = d3.scaleLinear().domain([-25, 25]).range([height, 0]);

/*
  Sizing model (multi-metric, additive):

    radius = BASE_R + sum_i add_i(value_i)

  Each add_i uses robust, capped log scaling so:
  - citations differences are more visible
  - likes/stars no longer become huge and "all the same"
*/
var BASE_R = 5;

/* Per-metric additive contribution functions (built after data load) */
var sizeAdd = {
  citations: null,
  huggingface_likes: null,
  github_stars: null
};

/* Per-metric max additive radius (tuning knobs) */
var sizeAddMax = {
  citations: 22,          // larger spread (citations should be clearly visible)
  huggingface_likes: 14,  // smaller to avoid dominating
  github_stars: 14
};

/* ----------------- Tooltip (HTML overlay) ----------------- */
var tooltip = d3.select("#paperviz")
  .append("div")
  .style("opacity", 0)
  .attr("class", "tooltip")
  .style("background-color", "rgb(81, 81, 81)")
  .style("max-width", "min(90vw, 42ch)")
  .style("color", "white")
  .style("border-width", "0px")
  .style("border-radius", "10px")
  .style("padding", "10px")
  .style("position", "absolute");

function showTooltip(){ tooltip.style("opacity", 1); }
function hideTooltip(){ tooltip.style("opacity", 0); }

/* ----------------- Size-by helpers (checkboxes) ----------------- */
function getSelectedSizeMetrics(){
  var boxes = Array.from(document.querySelectorAll(".sizeByMetric"));
  return boxes.filter(b => b.checked).map(b => b.value);
}

function setSelectedSizeMetrics(metrics){
  var set = new Set(metrics || []);
  Array.from(document.querySelectorAll(".sizeByMetric")).forEach(b => {
    b.checked = set.has(b.value);
  });
}

/* ----------------- URL State helpers ----------------- */
function getState() {
  return {
    q: d3.select("#filtermap").property("value"),
    cluster: selectedCluster,
    y0: selectedYearMin,
    y1: selectedYearMax,
    sz: getSelectedSizeMetrics().join(",")
  };
}

function setStateFromURL() {
  const p = new URLSearchParams(location.search);
  if (p.get("q")) d3.select("#filtermap").property("value", p.get("q"));
  const c = p.get("cluster");
  if (c !== null && c !== undefined) selectedCluster = c;

  const y0 = parseInt(p.get("y0"));
  const y1 = parseInt(p.get("y1"));
  if (!isNaN(y0)) selectedYearMin = y0;
  if (!isNaN(y1)) selectedYearMax = y1;

  const sz = p.get("sz");
  if (sz){
    const metrics = sz.split(",").map(s => s.trim()).filter(Boolean);
    setSelectedSizeMetrics(metrics);
  }
}

function pushState() {
  const s = getState();
  const p = new URLSearchParams();
  if (s.q) p.set("q", s.q);
  if (s.cluster !== null && s.cluster !== undefined && s.cluster !== "null") p.set("cluster", s.cluster);
  if (s.y0 !== null && s.y0 !== undefined) p.set("y0", s.y0);
  if (s.y1 !== null && s.y1 !== undefined) p.set("y1", s.y1);
  if (s.sz) p.set("sz", s.sz);
  const u = `${location.pathname}?${p.toString()}`;
  history.replaceState(null, "", u);
}

/* ----------------- Zoom ----------------- */
var zoom = d3.zoom()
  .scaleExtent([0.4, 20])
  .on("zoom", function(event) {
    currentTransform = event.transform;
    draw(); // redraw canvas, no transitions
  });

d3.select(canvas).call(zoom);

/* ----------------- Sizing functions ----------------- */
function buildRobustAddScale(values, addMax, capQuantile){
  // values: array of non-negative numbers
  // addMax: max added radius for this metric
  // capQuantile: e.g. 0.98..0.99 to clamp outliers
  var vs = values
    .map(v => +v || 0)
    .filter(v => v > 0)
    .sort((a,b) => a - b);

  if (!vs.length || addMax <= 0){
    return function(){ return 0; };
  }

  var q = (capQuantile == null ? 0.98 : capQuantile);
  q = Math.max(0.5, Math.min(0.999, q));

  var cap = d3.quantile(vs, q);
  cap = Math.max(1, cap || 1);

  var denom = Math.log1p(cap);

  return function(v){
    var x = +v || 0;
    if (x <= 0) return 0;
    if (x > cap) x = cap;

    var t = Math.log1p(x) / denom;   // 0..1
    if (!isFinite(t)) t = 0;
    t = Math.max(0, Math.min(1, t));

    return t * addMax;
  };
}

function computeRadius(d){
  var selected = getSelectedSizeMetrics();
  if (!selected.length) return BASE_R;

  var r = BASE_R;

  for (var i = 0; i < selected.length; i++){
    var m = selected[i];
    var f = sizeAdd[m];
    if (typeof f === "function"){
      r += f(d[m]);
    }
  }

  // Keep extremes sane but still visibly separated
  r = Math.max(3.5, Math.min(r, 42));
  return r;
}

function computeFill(d, searchTerm, byYearColour){
  const st = searchTerm;
  const highlight = isMatch(d, st);
  if (highlight) return "#aa0000";
  if (byYearColour && !isNaN(d.year)) return colorYear(d.year);
  return color(d.cluster);
}

/* ----------------- Precompute pixel positions + quadtree ----------------- */
function recomputePositionsAndIndex(){
  allData.forEach(d => {
    d._px = x(d.tsne_embedding[0]);
    d._py = y(d.tsne_embedding[1]);
  });

  quadtree = d3.quadtree()
    .x(d => d._px)
    .y(d => d._py)
    .addAll(allData);
}

/* ----------------- Canvas sizing (HiDPI, crisp) ----------------- */
function resizeCanvas(){
  const parent = document.getElementById("paperviz");
  const w = Math.max(280, parent.clientWidth) - margin.left - margin.right;
  const h = Math.max(260, Math.round(w * 0.66));
  width = w; height = h;

  x.range([0, width]);
  y.range([height, 0]);

  dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor((width + margin.left + margin.right) * dpr);
  canvas.height = Math.floor((height + margin.top + margin.bottom) * dpr);
  canvas.style.width = (width + margin.left + margin.right) + "px";
  canvas.style.height = (height + margin.top + margin.bottom) + "px";

  if (allData.length) {
    recomputePositionsAndIndex();
  }
  draw();
}

const ro = new ResizeObserver(resizeCanvas);
ro.observe(document.getElementById("paperviz"));
resizeCanvas();

/* ----------------- Initial zoom / reset ----------------- */
function applyInitialZoom() {
  const t = d3.zoomIdentity
    .translate((width) / 2, (height) / 2)
    .scale(0.45)
    .translate(-(width) / 2, -(height) / 2);

  d3.select(canvas).call(zoom.transform, t);
  currentTransform = t;
}

/* ----------------- Draw (Canvas) ----------------- */
function clearCanvas(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function draw(){
  if (!ctx) return;

  clearCanvas();

  const searchTerm = (d3.select("#filtermap").property("value") || "").toLowerCase();
  const byYearColour = d3.select("#colorByYear").property("checked");

  ctx.save();
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.translate(margin.left, margin.top);
  ctx.translate(currentTransform.x, currentTransform.y);
  ctx.scale(currentTransform.k, currentTransform.k);

  for (let i = 0; i < filteredData.length; i++){
    const d = filteredData[i];
    const r = computeRadius(d);
    const fill = computeFill(d, searchTerm, byYearColour);

    ctx.beginPath();
    ctx.arc(d._px, d._py, r, 0, Math.PI * 2);

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = fill;
    ctx.fill();

    ctx.globalAlpha = 1;
    ctx.strokeStyle = "white";
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  if (hovered){
    const d = hovered;
    const r = computeRadius(d);
    ctx.beginPath();
    ctx.arc(d._px, d._py, r + 2, 0, Math.PI * 2);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(255,255,255,.95)";
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  ctx.restore();

  const loader = document.getElementById("loadingViz");
  if (loader) loader.style.display = "none";
}

/* ----------------- Tooltip: throttle + update only on hovered change ----------------- */
function updateTooltipContent(d){
  const tags = (d.tags || []).slice(0, 6).map(t => `<tag>${t}</tag>`).join(" ");
  tooltip.html(`
    <div style="font-weight:600; margin-bottom:4px;">${d.title}</div>
    <div style="font-size:12px; opacity:.9;">
      ${d.conference || "‚Äî"} ‚Ä¢ ${d.year || "n/a"} ‚Ä¢ Citations: ${d.citations || 0}
      ‚Ä¢ HF Likes: ${d.huggingface_likes || 0} ‚Ä¢ GitHub Stars: ${d.github_stars || 0}
    </div>
    <div style="margin-top:6px; font-size:12px;">${tags}</div>
  `);
}

function positionTooltip(clientX, clientY){
  const container = document.getElementById("paperviz");
  const cr = container.getBoundingClientRect();
  const ttNode = tooltip.node();
  const ttWidth = ttNode.offsetWidth;
  const ttHeight = ttNode.offsetHeight;

  const mx = clientX - cr.left;
  const my = clientY - cr.top;

  const offsetY = 12;
  let left = mx - ttWidth / 2;
  let top  = my  - ttHeight - offsetY;

  const pad = 8;
  left = Math.max(pad, Math.min(left, cr.width  - ttWidth  - pad));
  top  = Math.max(pad, Math.min(top,  cr.height - ttHeight - pad));

  tooltip.style("left", left + "px").style("top", top + "px");
}

function getPlotCoordsFromEvent(evt){
  const rect = canvas.getBoundingClientRect();
  const mx = evt.clientX - rect.left;
  const my = evt.clientY - rect.top;

  const px = (mx - margin.left - currentTransform.x) / currentTransform.k;
  const py = (my - margin.top  - currentTransform.y) / currentTransform.k;

  return { px, py, mx, my };
}

function isDatumInFiltered(d){
  return filteredKeySet && filteredKeySet.has(d.key);
}

var filteredKeySet = null;

function handleHoverRAF(){
  hoverRAF = 0;
  if (!lastMouse || !quadtree || !allData.length) return;

  const evt = lastMouse;
  const { px, py } = getPlotCoordsFromEvent(evt);

  const pickRadius = 10 / currentTransform.k;

  let candidate = quadtree.find(px, py, pickRadius);
  if (candidate && !isDatumInFiltered(candidate)) {
    candidate = null;
  }

  const changed =
    (!!candidate && (!hovered || hovered.key !== candidate.key)) ||
    (!!hovered && !candidate);

  if (changed){
    hovered = candidate || null;
    draw();
  }

  if (hovered){
    showTooltip();
    if (changed && hovered){
      updateTooltipContent(hovered);
    }
    positionTooltip(evt.clientX, evt.clientY);
  } else {
    hideTooltip();
  }
}

/* Bind canvas pointer events */
canvas.addEventListener("mousemove", function(evt){
  lastMouse = evt;
  if (!hoverRAF){
    hoverRAF = requestAnimationFrame(handleHoverRAF);
  }
}, { passive: true });

canvas.addEventListener("mouseleave", function(){
  lastMouse = null;
  if (hovered){
    hovered = null;
    draw();
  }
  hideTooltip();
}, { passive: true });

canvas.addEventListener("click", function(){
  if (hovered && hovered.key){
    window.location.href = "/publications/" + hovered.key + "/";
  }
}, { passive: true });

/* ----------------- Data load & visualization ----------------- */
Promise.all([
  d3.json('./tsne_clustered.json'),
  d3.json('cluster_summary.json')
]).then(function(results) {
  const data = results[0];
  const summary = results[1];

  allData = data;

  allData.forEach(function(d) {
    d.year = parseInt(d.year);
    d.citations = +d.citations || 0;
    d.huggingface_likes = +d.huggingface_likes || 0;
    d.github_stars = +d.github_stars || 0;

    const authors = Array.isArray(d.authors) ? d.authors.join(" ") : (d.authors || "");
    d._searchText = [
      d.title || "",
      d.abstract || "",
      (d.tags || []).join(" "),
      authors,
      d.conference || "",
      d.key || "",
      d.year || ""
    ].join(" ").toLowerCase();
  });

  const years = allData.map(d => d.year).filter(y => !isNaN(y));
  yearMinBound = d3.min(years);
  yearMaxBound = d3.max(years);

  if (yearMinBound != null && yearMaxBound != null) {
    colorYear.domain([yearMinBound, yearMaxBound]);
  }

  // Robust sizing: clamp outliers and log-scale so social metrics don't "all look the same"
  sizeAdd.citations = buildRobustAddScale(
    allData.map(d => d.citations),
    sizeAddMax.citations,
    0.985
  );

  sizeAdd.huggingface_likes = buildRobustAddScale(
    allData.map(d => d.huggingface_likes),
    sizeAddMax.huggingface_likes,
    0.98
  );

  sizeAdd.github_stars = buildRobustAddScale(
    allData.map(d => d.github_stars),
    sizeAddMax.github_stars,
    0.98
  );

  // Apply URL state first (may set selected size metrics)
  setStateFromURL();

  if (selectedYearMin === null) selectedYearMin = yearMinBound;
  if (selectedYearMax === null) selectedYearMax = yearMaxBound;

  // Init year controls and show them
  const yearControls = document.getElementById("yearControls");
  const yearMinInput = document.getElementById("yearMin");
  const yearMaxInput = document.getElementById("yearMax");
  const yearMinVal = document.getElementById("yearMinVal");
  const yearMaxVal = document.getElementById("yearMaxVal");
  const clearYearBtn = document.getElementById("clearYear");

  yearMinInput.min = yearMinBound;
  yearMinInput.max = yearMaxBound;
  yearMaxInput.min = yearMinBound;
  yearMaxInput.max = yearMaxBound;

  yearMinInput.value = selectedYearMin;
  yearMaxInput.value = selectedYearMax;
  yearMinVal.textContent = selectedYearMin;
  yearMaxVal.textContent = selectedYearMax;

  yearControls.style.display = "flex";

  function clampYearInputs(){
    let v0 = parseInt(yearMinInput.value);
    let v1 = parseInt(yearMaxInput.value);
    if (v0 > v1) {
      const tmp = v0; v0 = v1; v1 = tmp;
      yearMinInput.value = v0;
      yearMaxInput.value = v1;
    }
    selectedYearMin = v0;
    selectedYearMax = v1;
    yearMinVal.textContent = v0;
    yearMaxVal.textContent = v1;
  }

  let yearDebounce;
  yearMinInput.addEventListener("input", function(){
    clampYearInputs();
    clearTimeout(yearDebounce);
    yearDebounce = setTimeout(updateVisualization, 80);
  });
  yearMaxInput.addEventListener("input", function(){
    clampYearInputs();
    clearTimeout(yearDebounce);
    yearDebounce = setTimeout(updateVisualization, 80);
  });
  clearYearBtn.addEventListener("click", function(){
    selectedYearMin = yearMinBound;
    selectedYearMax = yearMaxBound;
    yearMinInput.value = selectedYearMin;
    yearMaxInput.value = selectedYearMax;
    yearMinVal.textContent = selectedYearMin;
    yearMaxVal.textContent = selectedYearMax;
    updateVisualization();
  });

  /* ---------- Legend: cluster vs year modes ---------- */
  const legendContainer = d3.select("#cluster-legend");
  const legendTitleEl = document.querySelector("#cluster-legend-wrapper h3");
  const resetClustersBtnEl = document.getElementById("resetClusters");

  const countsByCluster = d3.rollup(allData, v => v.length, d => String(d.cluster));

  function renderClusterLegend(summaryObj){
    legendTitleEl.textContent = "üß≠ Cluster Legend";
    resetClustersBtnEl.style.display = "inline-block";
    resetClustersBtnEl.disabled = false;
    legendContainer.selectAll("*").remove();

    Object.entries(summaryObj).forEach(([cluster, tags]) => {
      const count = countsByCluster.get(String(cluster)) || 0;
      const colorHex = color(cluster);

      const item = legendContainer.append("button")
        .attr("type", "button")
        .attr("class", "legend-item")
        .attr("data-cluster", cluster)
        .attr("aria-pressed", String(String(selectedCluster) === String(cluster)))
        .attr("title", `Toggle Cluster ${Number(cluster)+1}`)
        .on("click", function() {
          selectedCluster = (String(selectedCluster) === String(cluster)) ? null : cluster;
          renderClusterLegend(summaryObj);
          updateVisualization();
        });

      item.append("span")
        .attr("class", "legend-dot")
        .style("background", colorHex);

      const text = item.append("span").attr("class", "legend-text");

      const topRow = text.append("span").attr("class", "legend-row");
      topRow.append("span")
        .attr("class", "legend-title")
        .text(`Cluster ${Number(cluster)+1}`);
      topRow.append("span")
        .attr("class", "legend-count")
        .text(`${count} papers`);

      const tagRow = text.append("span").attr("class", "legend-tags");
      (tags || []).slice(0, 5).forEach(t => {
        tagRow.append("span").attr("class", "legend-tag").text(t.tag);
      });
    });
  }

  function buildYearBins(){
    const bins = [];
    if (yearMinBound == null || yearMaxBound == null) return bins;
    const span = yearMaxBound - yearMinBound + 1;
    const desiredBins = 5;
    const binSize = Math.max(1, Math.floor(span / desiredBins));

    let start = yearMinBound;
    while (start <= yearMaxBound){
      const end = Math.min(yearMaxBound, start + binSize - 1);
      const mid = (start + end) / 2;
      const count = allData.filter(d => !isNaN(d.year) && d.year >= start && d.year <= end).length;
      bins.push({ start, end, mid, count });
      start = end + 1;
    }
    return bins;
  }

  function renderYearLegend(){
    legendTitleEl.textContent = "üìÖ Year Legend";
    resetClustersBtnEl.style.display = "inline-block";
    resetClustersBtnEl.disabled = true;
    legendContainer.selectAll("*").remove();

    const bins = buildYearBins();
    bins.forEach(bin => {
      const isOutside =
        (selectedYearMin != null && bin.end < selectedYearMin) ||
        (selectedYearMax != null && bin.start > selectedYearMax);

      const isActive =
        !isOutside &&
        selectedYearMin != null &&
        selectedYearMax != null &&
        selectedYearMin === bin.start &&
        selectedYearMax === bin.end;

      const item = legendContainer.append("button")
        .attr("type", "button")
        .attr("class", "legend-item")
        .attr("aria-pressed", isActive ? "true" : "false")
        .attr("title", isOutside ? "Outside selected year range" : "Click to filter to this year range")
        .style("opacity", isOutside ? 0.35 : 1)
        .on("click", function(){
          selectedYearMin = bin.start;
          selectedYearMax = bin.end;

          yearMinInput.value = selectedYearMin;
          yearMaxInput.value = selectedYearMax;
          yearMinVal.textContent = selectedYearMin;
          yearMaxVal.textContent = selectedYearMax;

          updateVisualization();
        });

      item.append("span")
        .attr("class", "legend-dot")
        .style("background", colorYear(bin.mid));

      const text = item.append("span").attr("class", "legend-text");
      const row = text.append("span").attr("class", "legend-row");
      const label = (bin.start === bin.end) ? `${bin.start}` : `${bin.start}‚Äì${bin.end}`;
      row.append("span")
        .attr("class", "legend-title")
        .text(label);

      row.append("span")
        .attr("class", "legend-count")
        .text(`${bin.count} papers`);
    });
  }

  function renderLegendMode(useYearLegend){
    if (useYearLegend) renderYearLegend();
    else renderClusterLegend(summary);
  }

  renderLegendMode(d3.select("#colorByYear").property("checked"));

  d3.select("#resetClusters").on("click", function() {
    if (d3.select("#colorByYear").property("checked")) return;
    selectedCluster = null;
    renderClusterLegend(summary);
    updateVisualization();
  });

  /* ---------- Core update (filtering only; drawing handled by canvas) ---------- */
  updateVisualization = function() {
    var searchTerm = (d3.select("#filtermap").property("value") || "").toLowerCase();
    var byYearColour = d3.select("#colorByYear").property("checked");

    renderLegendMode(byYearColour);

    filteredData = allData.filter(d => {
      const textMatch = !searchTerm || isMatch(d, searchTerm);
      const clusterMatch = (selectedCluster === null) || (String(d.cluster) === String(selectedCluster));
      const hasYear = !isNaN(d.year);
      const yearMatch = hasYear ? (d.year >= selectedYearMin && d.year <= selectedYearMax) : true;
      return textMatch && clusterMatch && yearMatch;
    });

    filteredKeySet = new Set(filteredData.map(d => d.key));

    if (hovered && !filteredKeySet.has(hovered.key)){
      hovered = null;
      hideTooltip();
    }

    d3.select("#matchCount").text("Matching papers: " + filteredData.length);
    pushState();

    draw();
  };

  recomputePositionsAndIndex();

  applyInitialZoom();
  updateVisualization();

  /* UI bindings */
  let debounceTimer;
  d3.select("#filtermap").on("keyup", function() {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(updateVisualization, 200);
  });

  /* Zoom controls */
  d3.select("#zoom_in").on("click", () =>
    d3.select(canvas).transition().call(zoom.scaleBy, 1.2)
  );
  d3.select("#zoom_out").on("click", () =>
    d3.select(canvas).transition().call(zoom.scaleBy, 0.8)
  );
  d3.select("#reset_view").on("click", () => {
    applyInitialZoom();
    const hint = document.getElementById("gestureHint");
    if (hint){ hint.classList.add("show"); setTimeout(()=>hint.classList.remove("show"), 1500); }
  });

  // Size-by checkboxes (multi-select)
  Array.from(document.querySelectorAll(".sizeByMetric")).forEach(cb => {
    cb.addEventListener("change", updateVisualization, { passive: true });
  });

  // "No size" button
  const clearSizeBtn = document.getElementById("clearSize");
  if (clearSizeBtn){
    clearSizeBtn.addEventListener("click", function(){
      setSelectedSizeMetrics([]);
      updateVisualization();
    }, { passive: true });
  }

  // Colour by year
  d3.select("#colorByYear").on("change", updateVisualization);

  /* One-time gesture hint on first load */
  (function gestureHintOnce(){
    const hint = document.getElementById("gestureHint");
    if (!hint) return;
    if (localStorage.getItem("paperviz-hinted")) return;
    hint.classList.add("show");
    setTimeout(() => hint.classList.remove("show"), 2200);
    localStorage.setItem("paperviz-hinted", "1");
  })();

}).catch(function(err) {
  const loader = document.getElementById("loadingViz");
  if (loader) loader.textContent = "Failed to load data.";
  console.error("Data load error:", err);
});

/* Clear search */
d3.select("#clearSearch").on("click", function() {
  d3.select("#filtermap").property("value", "");
  updateVisualization();
});

/* Keyboard shortcuts */
document.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "k") {
    e.preventDefault();
    document.getElementById("filtermap").focus();
  } else if (e.key === "Escape") {
    d3.select("#filtermap").property("value", "");
    updateVisualization();
  } else if (e.key.toLowerCase() === "r") {
    const resetBtn = document.getElementById("reset_view");
    if (resetBtn) resetBtn.click();
  }
});
</script>
